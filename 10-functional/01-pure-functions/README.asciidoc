= Funciones puras
:source-highlighter: highlightjs

== Introducción

Las funciones puras tienen aplicaciones en muchos ámbitos, entre ellos la
programación funcional. También facilita la concurrencia, y como veremos en
siguientes etapas serán muy empleadas en aplicaciones basadas en React+Redux.

Anteriormente mencionamos que una función es básicamente un proceso que
toma una entrada o argumentos, y produce una salida o valor de retorno. También
hemos visto que las funciones se emplean con ciertos propósitos:

Manipulación de datos:: Transforma una serie de argumentos o entrada en un valor
de retorno. Un ejemplo de esto sería hacer _flattening_ footnote:[Algunas veces
necesitamos aplanar árboles u objetos muy anidados que son resultado de una
consulta o _query_, un patrón común es convertirlos en arreglos o _arrays_ para
luego poder aplicar operaciones como `filter()` o `map()` sobre ellos.] de un
objeto muy anidado.
Procedimientos:: Una función puede ser llamada para realizar una serie de pasos
(receta). *La secuencia es conocida como procedimiento* (primero haz esto, luego
haz aquello), el estilo de programación bajo este estilo se denomina
*programación imperativa*.
Entrada/Salida:: Algunas funciones existen para comunicarse con otras partes o
subsistemas, por ejemplo: la pantalla, almacenamiento, registro de operaciones
en disco, operaciones a través de la red.

Una vez vistas las diversas aplicaciones de las funciones procedamos a dejar
claro que significa una _función pura_.

[.lead]
En *programación funcional*, el comportamiento de las funciones dependen de una
y solo una cosa: los argumentos pasados explícitamente a la función. Esto quiere
decir que si usted proporciona los mismos datos como argumentos o entrada, la
función siempre debe producir el mismo valor de retorno. A esta propiedad se le
conoce como *transparencia referencial*.

Lo mencionado en el párrafo anterior, hace que en las funciones puras sea más
fácil apreciar todas las circunstancias que pueden presentarse, incluyendo
aquellos escenarios que conllevan a un error. Escribir funciones que solo
dependen de sus argumentos para definir su comportamiento también facilita
replicar _bugs_ o poner en práctica _Test-Driven Development_ o TDD por sus
siglas en inglés.

Comencemos desarrollando nuestros casos de pruebas:

[[lowercaser-test-listing]]
[source,js]
.lowercaser.test.js
----
include::lowercaser.test.js[]
----

.Nota
[NOTE]
====
A lo largo del curso usaremos https://facebook.github.io/jest/[Jest] como
_framework_ para la ejecución de pruebas unitarias. Puedes instalar *Jest*
por medio de `npm` al ejecutar el siguiente comando:

[source,console]
$ npm install --save-dev jest

O también puedes usar `yarn` al ejecutar:

[source,console]
$ yarn add --dev jest

Para correr las pruebas haremos:

[source,console]
$ yarn run jest fichero.test.js
====

Ahora, pasemos a implementar lo especificado en nuestros casos de pruebas:

[[lowercaser-listing]]
[source,js]
.lowercaser.js
----
include::lowercaser.js[]
----

Una vez completada nuestra implementación inicial, corroboremos nuestro trabajo
por medio de la ejecución de las pruebas:

[[lowercaser-output-listing]]
[source,console]
----
include::lowercaser.output[]
----

Parece que todo funciona como se espera. Continuemos.

== Dada la misma entrada, devuelve siempre la misma salida

Con nuestra función `lowerCaser()`, puede reemplazar la llamada de la función
por el resultado, y el código tendrá el mismo significado
`lowerCaser('LOREM IPSUM')` siempre será lo mismo que `lorem ipsum` en su
programa, sin importar el contexto, cuantas veces lo llame o cuando lo llame.

Pero no se puede decir lo mismo de todas las funciones. Algunas funciones se
basan en información distinta de los argumentos que se transmiten para producir
resultados. Considere este ejemplo:

[[math-random-listing]]
[source,javascript]
----
Math.random() // => 0.4011148700956255
Math.random() // => 0.8533405303023756
Math.random() // => 0.3550692005082965
----

A pesar que no pasamos ningún argumento en ninguna de las llamadas a la
función, todos produjeron resultados diferentes, lo que significa que
`Math.random()` *no es una función pura*. `Math.random()` produce un nuevo
número aleatorio entre 0 y 1 cada vez que lo ejecutas, entonces es obvio que no
se podría simplemente reemplazarlo por `0.4011148700956255` sin cambiar el
significado del programa.

Eso produciría el mismo resultado cada vez que se ejecute el programa. Cuando le
pedimos a la computadora un número aleatorio, por lo general significa que
queremos un resultado diferente al que obtuvimos la última vez. ¿Cuál es el
punto de un par de dados con los mismos números impresos en todas las caras? A
veces tenemos que preguntarle a la computadora por la hora actual. No vamos a
entrar en detalles de cómo funcionan las funciones de tiempo. Por ahora,
simplemente copia este código:

[source,javascript]
----
const time = () => new Date().toLocaleTimeString()
time() // => "5:15:45 PM"
----

¿Qué sucedería si reemplazo la llamada de la función `time()` con la hora
actual? Siempre diría que es la misma hora: la hora con la cual la llamada a la
función se reemplazó. En otras palabras, sólo podría producir la salida correcta
una vez al día, y sólo si se ejecuta el programa en el momento exacto en que la
hora se reemplazó por la función.

Entonces, claramente, `time()` no es como la función `lowerCaser()` .

Una función sólo es pura si, dada la misma entrada, siempre producirá la misma
salida. Tal vez recuerdes esta regla de la clase de álgebra: los mismos valores
de entrada se asignarán siempre al mismo valor de salida. Sin embargo, muchos
valores de entrada se pueden asignar al mismo valor de salida. Por ejemplo, la
siguiente función es pura:

[source,javascript]
----
const highpass = (cutoff, value) => value >= cutoff;
----

Los mismos valores de entrada se asignarán siempre al mismo valor de salida:

[source,javascript]
----
highpass(5, 5) // => true
highpass(5, 5) // => true
highpass(5, 5) // => true
----

Muchos valores de entrada tal vez se pueden asignar al mismo valor de salida:

[source,javascript]
----
highpass(5, 123) // true
highpass(5, 6)   // true
highpass(5, 18)  // true
highpass(5, 1)   // false
highpass(5, 3)   // false
highpass(5, 4)   // false
----

== Efectos colaterales

En este punto cabe aclarar que las funciones puras no producen *efectos
colaterales* o _side-effects_, pues el propósito de vida de una función pura es
únicamente calcular el valor de retorno, solo eso y nada más.

Cabe aclarar que en este contexto, consideramos a un *efecto colateral* como
algo que sucede como resultado de llamar a una función y que *no es* el valor de
retorno de dicha función. En la programación funcional, los efectos
colaterales se usan con moderación. Ten en cuenta que la mutación de variables
es un tipo de efecto colateral.

Veamos un ejemplo de efecto colateral y como podemos evitarlo.

Supongamos que deseamos crear una función que concatene dos _arrays_ que pueden
contener elementos anidados, tratemos de emular el siguiente comportamiento:

[[concat-test-listing]]
[source,js]
.concat.test.js
----
include::concat.test.js[lines=1..9]
----

Una implementación inicial puede ser la siguiente:

[[concat-listing]]
[source,js]
.concat.js
----
include::concat.js[]
----
NOTE: Ten en cuenta que esta implementación es a modo de ejemplo, en realidad
podríamos usar https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/concat[Array.prototype.concat()]
directamente.

Comprobemos nuestro trabajo:

[[concat-output-listing]]
[source,console]
----
include::concat.output[]
----

Todo parece indicar que nuestra función tiene un comportamiento correcto, ahora
agreguemos un caso de prueba para comprobar que no estamos alterando el contexto
externo:

[[concat-complete-test-listing]]
[source,js]
.concat.test.js
----
include::concat.test.js[]
----

Al ejecutar las pruebas obtenemos lo siguiente:

[[concat-bad-output-listing]]
[source,console]
----
include::concat11.output[]
----

*Ouch!*, con esto se demuestra que nuestra *función no es pura* por ahora pues
estamos alterando el contexto externo, lo cual es un tipo de efecto colateral.

[.lead]
El comportamiento anterior sucede porque los objetos o arreglos pasados a las
funciones como argumento se pasan por referencia, no por copia, lo que significa
que si una función muta una propiedad en un objeto o arreglo, supondría que
dicha mutación sería accesible desde afuera de la función. Las funciones puras
no deben alterar el estado externo.

Si bien el valor de retorno de nuestra función es el esperado, el problema con
la implementación actual es que hemos mutado un estado compartido. Imagina por
un momento que otras funciones pueden depender del estado del arreglo u objeto
asumiendo que su estado es el original (antes de llamar a nuestra función
`concat`), y ahora que hemos mutado ese estado compartido, tenemos que
preocuparnos por el impacto que tendrá dicho cambio en la lógica del programa si
cambiamos el orden en que se han llamado las funciones. Refactorizar el código
podría resultar en errores apareciendo aquí y allá, lo que podría arruinar la
logica general de nuestra aplicación, y como resultado muchos clientes
disgustados.

Veamos ahora como podemos corregir esta situación:

[[concat-fix-listing]]
[source,js]
.concat.js
----
include::concat1.js[]
----

Ahora al ejecutar las pruebas obtenemos lo siguiente:

[[concat-good-output-listing]]
[source,console]
----
include::concat12.output[]
----

¿Recuerdas que antes habíamos mencionado que podíamos haber usado
`Array.prototype.concat` directamente?, pues veamos una simplificación del
código:

[[array-prototype-concat]]
[source,javascript]]
.concat.js
----
include::concat2.js[]
----

Si ejecutas de nuevo las pruebas unitarias verás que cumplimos con todas las
condiciones.

== Beneficios

Una vez analizadas las funciones puras podemos mencionar los siguientes
beneficios:

- [x] Toman ciertos argumentos como entrada y genera un valor de retorno que
exclusivamente depende de los argumentos dados.
- [x] Representan bloques de código reusable dentro de un programa.
- [x] Promueven buenas prácticas de desarrollo como https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY] (_Don't Repeat Yourself_)
y https://en.wikipedia.org/wiki/KISS_principle[KISS] (_Keep It Simple, Stupid_).
- [x] Al no depender del contexto externo, son inmunes a toda clase de errores o
_bugs_ que tienen que ver con el estado mutable compartido.
- [x] Su naturaleza independiente las hace excelentes candidatos para
procesamiento concurrente a lo largo de muchos CPUs e incluso para la
computación distribuida, lo cual las hace esenciales para la ejecución de tareas
de cálculo científico y de uso intensivo de recursos.
- [x] Su aislamiento facilita la refactorización y reorganización del código,
haciendo tú código más adaptable y flexible a futuros cambios.
- [x] Es mucho más sencillo el desarrollo de pruebas unitarias contra funciones
puras.
- [x] Las funciones puras representan la base de la programación funcional.

Por las razones antes mencionadas, recomendamos favorecer la implementación de
funciones puras. Por lo tanto, siempre que sea práctico implementar los
requerimientos de un programa usando funciones puras, debes darle preferencia
sobre otras opciones.

== Resumen

En la programación funcional, las programadoras tienden a evitar dos hábitos
comunes en otros lenguajes:

Mutación:: Cambio de los datos _in-situ_ en vez de retornar un valor.
Estado:: Contexto extra que no se provee como argumento a la función, por
ejemplo, variables globales.

Al no depender del estado ni de las mutaciones, el comportamiento de cada
función está contenido. Por lo tanto, es más sencillo realizar pruebas del
comportamiento de dichas funciones, entre otra serie de beneficios.

Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es
posible, especialmente en funciones que emplean _side-effects_ para llevar su
cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema, lo
veremos en una siguiente lección.

== Referencias

[bibliography]
- [[[lisp]]] Conrad Barski. 2010. Land of Lisp: Learn to Program in Lisp, One Game at a Time! (1st ed.). No Starch Press, San Francisco, CA, USA. Page 301.
- [[[eliot]]] https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976[Master the JavaScript Interview: What is a Pure Function?]. En Medium. Consultado el 11 de Julio de 2017
