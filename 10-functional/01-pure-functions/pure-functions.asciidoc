= Funciones puras
:source-highlighter: highlightjs

== Introducción

Las funciones puras tienen aplicaciones en muchos ámbitos, entre ellos la
programación funcional. Además, facilita la concurrencia, y como veremos en
subsiguientes etapas serán muy empleadas en aplicaciones basadas en React+Redux.

Como ya hemos mencionado en el pasado, una función es básicamente un proceso que
toma una entrada o argumentos, y produce una salida o valor de retorno. También
hemos visto que las funciones se emplean con ciertos propósitos:

Mapping:: Transforma una serie de argumentos o entrada en un valor de retorno.
Un ejemplo de esto sería hacer _flattening_ de un objeto muy anidado.
Procedures:: Una función puede ser llamada para realizar una serie de pasos
(receta). *La secuencia es conocida como procedimiento* (primero haz esto, luego
haz aquello), el estilo de programación bajo este estilo se denomina
*programación imperativa*.
I/O:: Algunas funciones existen para comunicarse con otras partes o
subsistemas, por ejemplo: la pantalla, almacenamiento, registro de operaciones
en disco, operaciones a través de la red.

Una vez vistas las diversas aplicaciones de las funciones procedamos a dejar
claro que significa una _función pura_.

[.lead]
En *programación funcional*, el comportamiento de las funciones dependen de una
y solo una cosa: los argumentos pasados explícitamente a la función. Esto quiere
decir que si usted proporciona los mismos datos como argumentos o entrada, la
función siempre debe producir el mismo valor de retorno. A esta propiedad se le
conoce como *transparencia referencial*.

Lo mencionado en el párrafo anterior, hace que en las funciones puras sea más
fácil apreciar todas las circunstancias que pueden presentarse, incluyendo
aquellos escenarios que conllevan a un error. Escribir funciones que solo
dependen de sus argumentos para definir su comportamiento también facilita
replicar _bugs_ o poner en práctica _Test-Driven Development_ o TDD por sus
siglas en inglés.

Comencemos desarrollando nuestros casos de pruebas:

[[lowercaser-test-listing]]
[source,js]
.lowercaser.test.js
----
include::lowercaser.test.js[]
----

.Nota
[NOTE]
====
A lo largo del curso usaremos https://facebook.github.io/jest/[Jest] como
_framework_ para la ejecución de pruebas unitarias. Puedes instalar *Jest*
por medio de `npm` al ejecutar el siguiente comando:

[source,console]
$ npm install --save-dev jest

O también puedes usar `yarn` al ejecutar:

[source,console]
$ yarn add --dev jest

Para correr las pruebas haremos:

[source,console]
$ yarn run jest fichero.test.js
====

Ahora, pasemos a implementar lo especificado en nuestros casos de pruebas:

[[lowercaser-listing]]
[source,js]
.lowercaser.js
----
include::lowercaser.js[]
----

Una vez completada nuestra implementación inicial, corroboremos nuestro trabajo
por medio de la ejecución de las pruebas:

[[lowercaser-output-listing]]
[source,console]
----
include::lowercaser.output[]
----

Parece que todo funciona como se espera. Continuemos.

== Efectos colaterales

En este punto cabe aclarar que las funciones puras no producen *efectos
colaterales* o _side-effects_, pues el propósito de vida de una función pura es
únicamente calcular el valor de retorno, solo eso y nada más.

Cabe aclarar que en este contexto, consideramos a un *efecto colateral* como
algo que sucede como resultado de llamar a una función y que *no es* el valor de
retorno de dicha función. En la programación funcional, los efectos
colaterales se usan con moderación. Ten en cuenta que la mutación de variables
es un tipo de efecto colateral.

Veamos un ejemplo de efecto colateral y como podemos evitarlo.

Supongamos que deseamos crear una función que concatene dos _arrays_ que pueden
contener elementos anidados, tratemos de emular el siguiente comportamiento:

[[concat-test-listing]]
[source,js]
.concat.test.js
----
include::concat.test.js[lines=1..9]
----

Una implementación inicial puede ser la siguiente:

[[concat-listing]]
[source,js]
.concat.js
----
include::concat.js[]
----

Comprobemos nuestro trabajo:

[[concat-output-listing]]
[source,console]
----
include::concat.output[]
----

Todo parece indicar que nuestra función tiene un comportamiento correcto, ahora
agreguemos un caso de prueba para comprobar que no estamos alterando el contexto
externo:

[[concat-complete-test-listing]]
[source,js]
.concat.test.js
----
include::concat.test.js[]
----

Al ejecutar las pruebas obtenemos lo siguiente:

[[concat-bad-output-listing]]
[source,console]
----
include::concat11.output[]
----

*Ouch!*, con esto se demuestra que nuestra *función no es pura* por ahora pues
estamos alterando el contexto externo, lo cual es un tipo de efecto colateral.

[.lead]
El comportamiento anterior sucede porque los objetos o arreglos pasados a las
funciones como argumento se pasan por referencia, no por copia, lo que significa
que si una función muta una propiedad en un objeto o arreglo, supondría que
dicha mutación sería accesible desde afuera de la función. Las funciones puras
no deben alterar el estado externo.

Si bien el valor de retorno de nuestra función es el esperado, el problema con
la implementación actual es que hemos mutado un estado compartido. Imagina por
un momento que otras funciones pueden depender del estado del arreglo u objeto
asumiendo que su estado es el original (antes de llamar a nuestra función
`concat`), y ahora que hemos mutado ese estado compartido, tenemos que
preocuparnos por el impacto que tendrá dicho cambio en la lógica del programa si
cambiamos el orden en que se han llamado las funciones. Refactorizar el código
podría resultar en errores apareciendo aquí y allá, lo que podría arruinar la
logica general de nuestra aplicación, y como resultado muchos clientes
disgustados.

Veamos ahora como podemos corregir esta situación:

[[concat-fix-listing]]
[source,js]
.concat.js
----
include::concat1.js[]
----

Ahora al ejecutar las pruebas obtenemos lo siguiente:

[[concat-good-output-listing]]
[source,console]
----
include::concat12.output[]
----

== Beneficios

Una vez analizadas las funciones puras podemos mencionar los siguientes
beneficios:

- [x] Toman ciertos argumentos como entrada y genera un valor de retorno que
exclusivamente depende de los argumentos dados.
- [x] Representan bloques de código reusable dentro de un programa.
- [x] Promueven buenas prácticas de desarrollo como https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY] (_Don't Repeat Yourself_)
y https://en.wikipedia.org/wiki/KISS_principle[KISS] (_Keep It Simple, Stupid_).
- [x] Al no depender del contexto externo, son inmunes a toda clase de errores o
_bugs_ que tienen que ver con el estado mutable compartido.
- [x] Su naturaleza independiente las hace excelentes candidatos para
procesamiento concurrente a lo largo de muchos CPUs e incluso para la
computación distribuida, lo cual las hace esenciales para la ejecución de tareas
de cálculo científico y de uso intensivo de recursos.
- [x] Su aislamiento facilita la refactorización y reorganización del código,
haciendo tú código más adaptable y flexible a futuros cambios.
- [x] Es mucho más sencillo el desarrollo de pruebas unitarias contra funciones
puras.
- [x] Las funciones puras representan la base de la programación funcional.

Por las razones antes mencionadas, recomendamos favorecer la implementación de
funciones puras. Por lo tanto, siempre que sea práctico implementar los
requerimientos de un programa usando funciones puras, debes darle preferencia
sobre otras opciones.

== Resumen

En la programación funcional, las programadoras tienden a evitar dos hábitos
comunes en otros lenguajes:

Mutación:: Cambio de los datos _in-situ_ en vez de retornar un valor.
Estado:: Contexto extra que no se provee como argumento a la función, por
ejemplo, variables globales.

Al no depender del estado ni de las mutaciones, el comportamiento de cada
función está contenido. Por lo tanto, es más sencillo realizar pruebas del
comportamiento de dichas funciones, entre otra serie de beneficios.

Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es
posible, especialmente en funciones que emplean _side-effects_ para llevar su
cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema, lo
veremos en una siguiente lección.

== Referencias

[bibliography]
- [[[lisp]]] Conrad Barski. 2010. Land of Lisp: Learn to Program in Lisp, One Game at a Time! (1st ed.). No Starch Press, San Francisco, CA, USA. Page 301.
- [[[eliot]]] https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976[Master the JavaScript Interview: What is a Pure Function?]. En Medium. Consultado el 11 de Julio de 2017
